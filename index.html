<!DOCTYPE html>
<html>
<head>
	<style>
        body {
            background-color: black;
        } 
        p {
            font-size: 2em;
            font-family: Arial;
            color: #fff;
        }
        #overlay {
            position: absolute;
            text-align: center;
            margin-left: 50px;
        }
        #artname {
            font-size: 3.5em;
            margin-bottom: 0em;
        }
        #name {
            margin: 0em;
        }
        #description {
            font-size: 1.5em;
            margin-top: .5em;
        }
        #url {
            font-size: 1em;
        }
        #contact {
            font-size: 1em;
            margin-bottom: 8em;
        }

    </style>
    <title>Planet3/art//news</title>
    <script>
    // To do:
    // - ON PUZZLE CLICK STILL FIRING WHEN INIT GAME INSTEAD OF SHUFFLEPIECES.
    // - Testing
    // - Resize image to correspond to the height x width. 
    // - Black background all around.

        //     //tablets:
               // 2560 x 1600
        //     // 1920 x 1200
        //     // 1280 x 800
        //     // 1024 x 768
        
        //     //phones:
        //     // 960 x 540
        //     // 854 x 480
               // 640 x 360
        //     // 480 x 320

        var difficulty = 1;
        var hoverTint = '#009900';

        var levelCounter = 0;

        var stage;
        var canvas;

        var img;
        var pieces;
        var puzzleWidth;
        var puzzleHeight;
        var pieceWidth;
        var pieceHeight;
        var currentPiece;
        var currentDropPiece;

        var mouse;

        //Called at the start of every new game and Level
        function init (){
        	difficulty +=1;
            levelCounter +=1;

            img = new Image();
            img.addEventListener('load',onImage,false);
          
            img.src = "./img/tablet/Gildens233w800.jpg";
        }

        function whichSrc (){
            if (window.innerHeight > 1599) {
                return "./img/HD/Gildens233h1600.jpg";
            } else 
            if (window.innerHeight < 1599 && window.innerHeight > 1199) {
                return "./img/tablet/Gildens233w1200.jpg";
            } else 
            if (window.innerHeight < 1199 && window.innerHeight > 799) {
                return "./img/tablet/Gildens233w800.jpg";
            } else 
            if (window.innerHeight < 799 && window.innerHeight > 760) {
                return "./img/tablet/Gildens233w768.jpg";
            }
        }

        function onImage (){
            pieceWidth = Math.floor(img.width / difficulty)
            pieceHeight = Math.floor(img.height / difficulty)
            puzzleWidth = pieceWidth * difficulty;
            puzzleHeight = pieceHeight * difficulty;
            setCanvas();
            initPuzzle();
        }

        function setCanvas (){
            console.log("setCanvas");
            canvas = document.getElementById('canvas');
            stage = canvas.getContext('2d');
            canvas.width = puzzleWidth;
            canvas.height = puzzleHeight;
            canvas.style.border = "1px solid black";
        }

        function initPuzzle (){
            console.log('initPuzzle');
            pieces = [];
            mouse = {x:0,y:0};

            currentPiece = null;
            currentDropPiece = null;
            stage.drawImage(img, 0, 0, puzzleWidth, puzzleHeight, 0, 0, puzzleWidth, puzzleHeight);
            if (levelCounter === 1) {
                createTitle("Click to Start");
                buildPieces();
                //resets movesCounter between levels
                movesCounter = 0;
            } else {
                createDomMessage("<p id='artname' class='deleteMe'>A Mother and Child</p>");
                createDomMessage("<p id='name' class='deleteMe'>Albert Gleizes, 1881 - 1953</p>");
                setTimeout(function() {
                    createDomMessage("<p id='description' class='deleteMe'>Painter and cubism theorist</p><br>");
                }, 500)
                setTimeout(function() {
                    createDomMessage("<p id='url' class='deleteMe'>www.gildensarts.com/</p><br>");
                }, 1000)
                setTimeout(function() {
                    createDomMessage("<p id='contact' class='deleteMe'>info@gildensarts.com</p><br>");
                }, 1000)
                setTimeout(function() {
                    createDomMessage("<p class='deleteMe'>Congratulations! You finished Level " + 
                    (levelCounter - 1) + " in " + movesCounter + " moves!</p>");
                    createDomMessage("<p class='deleteMe'>Ready for the Next Puzzle?</p>");

                    buildPieces();
                    //resets movesCounter between levels
                    movesCounter = 0;
                }, 1500)
                createTitle("Click to Start");
            }
        }
        function createDomMessage (message) {

            var overlayWidth = img.width - 100;
            var overlayHeight = img.height - 200;

            document.getElementById("overlay").style.width = overlayWidth + "px";
            document.getElementById("overlay").style.height = overlayHeight + "px";

            document.getElementById("overlay").style["top"] = "50px";
            document.getElementById("overlay").style["background-color"] = "rgba(0,0,0,0.4)";

            var parser = new DOMParser()
            var parsedHtml = parser.parseFromString(message, "text/html");
            var HTML = parsedHtml.childNodes[0];
            
            var parsedMessage = HTML.childNodes[1];
            document.getElementById("message").appendChild(parsedMessage.childNodes[0]);
        }

        function deleteDomMessage (classToDelete) {

            var deleteMes = document.getElementsByClassName(classToDelete);

            if (deleteMes[0] === null)  return;

            while (deleteMes[0]) {
                deleteMes[0].parentNode.removeChild(deleteMes[0]);
            }

            document.getElementById("overlay").style["background-color"] = "rgba(0,0,0,0)";
            document.getElementById("overlay").style["top"] = "0";
        }

        function createTitle (message){
            stage.fillStyle = "#000000";
            stage.globalAlpha = .4;
            stage.fillRect(50,puzzleHeight - 40,puzzleWidth - 100,100);
            stage.fillStyle = "#FFFFFF";
            stage.globalAlpha = 1;
            stage.textAlign = "center";
            stage.textBaseline = "middle";
            stage.font = "20px Arial";
            stage.fillText(message,puzzleWidth / 2,puzzleHeight - 20);
        }

        function buildPieces (){
            console.log('buildPieces');

            var i;
            var piece;
            var xPos = 0;
            var yPos = 0;
            for(i = 0;i < difficulty * difficulty;i++){
                piece = {};
                piece.sx = xPos;
                piece.sy = yPos;
                pieces.push(piece);
                xPos += pieceWidth;
                if(xPos >= puzzleWidth){
                    xPos = 0;
                    yPos += pieceHeight;
                }
            }
            document.onmousedown = shufflePuzzle;
        }

        function shufflePuzzle (){
            console.log('shufflePuzzle');

            deleteDomMessage("deleteMe");

            pieces = shuffleArrayPieces(pieces);
            stage.clearRect(0,0,puzzleWidth,puzzleHeight);
            var i;
            var piece;
            var xPos = 0;
            var yPos = 0;
            for(i = 0;i < pieces.length;i++){
                piece = pieces[i];
                piece.xPos = xPos;
                piece.yPos = yPos;
                stage.drawImage(img, piece.sx, piece.sy, pieceWidth, pieceHeight, xPos, yPos, pieceWidth, pieceHeight);
                stage.strokeRect(xPos, yPos, pieceWidth,pieceHeight);
                xPos += pieceWidth;
                if(xPos >= puzzleWidth){
                    xPos = 0;
                    yPos += pieceHeight;
                }
            }
            document.onmousedown = onPuzzleClick;
            document.addEventListener('touchstart', function (e) {
                // stop touch event
                e.stopPropagation();
                e.preventDefault();

                // translate to mouse event
                var clkEvt = document.createEvent('MouseEvent');
                clkEvt.initMouseEvent('mousedown', true, true, window, e.detail, 
                             e.touches[0].screenX, e.touches[0].screenY, 
                             e.touches[0].clientX, e.touches[0].clientY, 
                             false, false, false, false, 
                             0, null);
                document.dispatchEvent(clkEvt);

                // or just handle touch event
                onPuzzleClick(e);
            }, false);
        }

        function onPuzzleClick (e){
            console.log('onPuzzleClick');

            // to ensure on touch events, functions still work.
            if (e.touches){
                mouse.x = e.touches[0].clientX;
                mouse.y = e.touches[0].clientY;
            } else {
                if(e.layerX || e.layerX == 0){
                    mouse.x = e.layerX - canvas.offsetLeft;
                    mouse.y = e.layerY - canvas.offsetTop;
                }
                else if(e.offsetX || e.offsetX == 0){
                    mouse.x = e.offsetX - canvas.offsetLeft;
                    mouse.y = e.offsetY - canvas.offsetTop;
                }
            }
            currentPiece = checkPieceClicked();
            
            if(currentPiece != null){

                stage.clearRect(currentPiece.xPos,currentPiece.yPos,pieceWidth,pieceHeight);
                stage.save();
                stage.globalAlpha = .9;
                stage.drawImage(img, currentPiece.sx, currentPiece.sy, pieceWidth, pieceHeight, mouse.x - (pieceWidth / 2), mouse.y - (pieceHeight / 2), pieceWidth, pieceHeight);
                stage.restore();

                document.onmousemove = updatePuzzle;
                document.addEventListener('touchmove', function (e) {
                    // stop touch event
                    e.stopPropagation();
                    e.preventDefault();

                    // translate to mouse event
                    var clkEvt = document.createEvent('MouseEvent');
                    clkEvt.initMouseEvent('mousemove', true, true, window, e.detail, 
                                 e.touches[0].screenX, e.touches[0].screenY, 
                                 e.touches[0].clientX, e.touches[0].clientY, 
                                 false, false, false, false, 
                                 0, null);
                    document.dispatchEvent(clkEvt);

                    // or just handle touch event
                    updatePuzzle(e);
                }, false);

                document.onmouseup = pieceDropped;
                document.addEventListener('touchend', pieceDropped);
                return;
            }
        }

        function checkPieceClicked (e){
            var i;
            var piece;
            for(i = 0;i < pieces.length;i++){
                piece = pieces[i];
                if(mouse.x < piece.xPos || mouse.x > (piece.xPos + 
                    pieceWidth) || mouse.y < piece.yPos || mouse.y > (piece.yPos + 
                    pieceHeight)){
                    //return nothing so that loop continuess
                }
                else{
                    return piece;
                }
            }
            return null;
        }

        function updatePuzzle (e){
            currentDropPiece = null;

            if (e.touches){
            // if (e.layerX === 0){
                mouse.x = e.touches[0].clientX;
                mouse.y = e.touches[0].clientY;
            } else {
                if(e.layerX || e.layerX == 0){
                    mouse.x = e.layerX - canvas.offsetLeft;
                    mouse.y = e.layerY - canvas.offsetTop;
                }
                else if(e.offsetX || e.offsetX == 0){
                    mouse.x = e.offsetX - canvas.offsetLeft;
                    mouse.y = e.offsetY - canvas.offsetTop;
                }
            }

            stage.clearRect(0,0,puzzleWidth,puzzleHeight);
            var i;
            var piece;
            for(i = 0;i < pieces.length;i++){
                piece = pieces[i];
                if(piece == currentPiece){
                    continue;
                }
                stage.drawImage(img, piece.sx, piece.sy, pieceWidth, pieceHeight, piece.xPos, piece.yPos, pieceWidth, pieceHeight);
                stage.strokeRect(piece.xPos, piece.yPos, pieceWidth,pieceHeight);
                if(currentDropPiece == null){
                    if(mouse.x < piece.xPos || mouse.x > (piece.xPos + pieceWidth) || mouse.y < piece.yPos || mouse.y > (piece.yPos + pieceHeight)){
                        //NOT OVER
                    }
                    else{
                        currentDropPiece = piece;
                        stage.save();
                        stage.globalAlpha = .4;
                        stage.fillStyle = hoverTint;
                        stage.fillRect(currentDropPiece.xPos,currentDropPiece.yPos,pieceWidth, pieceHeight);
                        stage.restore();
                    }
                }
            }
            stage.save();
            stage.globalAlpha = .6;
            console.log(currentPiece);
            stage.drawImage(img, currentPiece.sx, currentPiece.sy, pieceWidth, pieceHeight, mouse.x - (pieceWidth / 2), mouse.y - (pieceHeight / 2), pieceWidth, pieceHeight);
            stage.restore();
            stage.strokeRect( mouse.x - (pieceWidth / 2), mouse.y - (pieceHeight / 2), pieceWidth,pieceHeight);
        }

        function pieceDropped (e){
            console.log("piece dropped");
            //Counts number of moves in each level
            movesCounter +=1;

            document.onmousemove = null;
            document.onmouseup = null;
            document.addEventListener('touchend');
            //do I need touch options for above?

            if(currentDropPiece != null){
                var tmp = {xPos:currentPiece.xPos,yPos:currentPiece.yPos};
                currentPiece.xPos = currentDropPiece.xPos;
                currentPiece.yPos = currentDropPiece.yPos;
                currentDropPiece.xPos = tmp.xPos;
                currentDropPiece.yPos = tmp.yPos;
            }
            resetPuzzleAndCheckWin();
        }
        function resetPuzzleAndCheckWin (){
            console.log("checkwin");
            stage.clearRect(0,0,puzzleWidth,puzzleHeight);
            var gameWin = true;
            var i;
            var piece;

            for(i = 0;i < pieces.length;i++){
                piece = pieces[i];
                stage.drawImage(img, piece.sx, piece.sy, pieceWidth, pieceHeight, piece.xPos, piece.yPos, pieceWidth, pieceHeight);
                stage.strokeRect(piece.xPos, piece.yPos, pieceWidth,pieceHeight);
                if(piece.xPos != piece.sx || piece.yPos != piece.sy){
                    gameWin = false;
                }
            }
            if(gameWin){
                setTimeout(gameOver,500);
            }
        }
        function gameOver (){
            console.log("gameover");
            document.onmousedown = null;
            document.onmousemove = null;
            document.onmouseup = null;
            //do I need touch options for above?
            document.addEventListener('touchend', function() {
                console.log("GameOver touchend")
            });

            if (levelCounter < 6 ) {
                init();
            } else {
                createMessage("You Won the Game!");
            }
        }
        function shuffleArrayPieces (pieces){
            for(var j, x, i = pieces.length; i; j = parseInt(Math.random() * i), x = pieces[--i], pieces[i] = pieces[j], pieces[j] = x);
            return pieces;
        }

    </script>
</head>

<body onload="init();">
    <div id="overlay">
        <div id="message"></div>
    </div>
    <div id= "canvas-container">
        <canvas id="canvas">Your Browser Doesn't support canvas. Update to Play!</canvas>
    </div>
</body>
</html>